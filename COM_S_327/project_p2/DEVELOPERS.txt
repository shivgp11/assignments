Functionalities implemented by Akhilesh Ratnakumar:
   1. Moved most of the header files into check.h
   2. Makefile changes to build advance
   3. Implemented the checks for the switch statements and the functionalities for -x, -o, -m N switches
   4. File format validation of MOVES: section in checkMoves function
   5. Validating each moves by themselves by comparing cards values in the conditionals in functions validateMove, compareCards, compareFoundationCards, compareSuit, 
      compareRank, compareFoundationRank
   6. Outputting to another file or standard output in either human readable format or game configuration output
   

int main(int argc, char* argv[])
Takes input and checks if there are switches besides filename. If file is parsed and no errors are thrown, outputs to based on 
the switches read. If not switches are read, prints to standard output.

int checkMoves(FILE* fp)
Takes file pointer fp and reads the MOVES: section of the file after it's been parsed. It then reads a single character to check if it is '.', 'eof' or 'r', otherwise it
takes in each move as a string of 4 characters named currentMove where it checks if it's in the correct format while keeping track of the number of moves. Then currentMove
is passed through validateMove which returns 0 if it is an invalid move. The function keeps parsing to the next move until it reaches eof. 

int validateMove(char* str)
Takes in the read move(which has a valid format) as a string and compares the src card and destination card. If cards are moving to foundations, the function 
compareFoundationCards will take the corresponding card from either the wastestack struct pointer or uncoveredcard[col number] struct pointer and the type of foundation
card. If it moving from waste to table or table column to table column, then it takes the corresponding struct pointers and passes them through the function compareCards
that returns 1 if it is valid.

int compareCards(node* card1, node* card2)
Takes in cards strictly from either waste to table or table column to table column. It checks if both functions compareSuit and compareRank returns 1 by passing in 
the suits and ranks of the cards as parameters. If they are valid, compareCards returns 1.

int compareSuit(char suitCard1, char suitCard2)
Takes suits from cards and checks if both of their combinations are valid in terms of the foundation suits. Returns 1 if valid.

int compareRank(char rankCard1, char rankCard2)
Take the ranks of both cards and checks if card 1's rank is lower than card 2's rank, and returns 1 if valid.

int compareFoundationCards(node* card1, node* card2)
Takes in either waste or table card as card1 and foundation card as card2 and first checks both cards suits. If they are the same, the function compareFoundationRank
is called passing the ranks of both cards as parameters. If both are valid compareFoundationCards returns 1.

int compareFoundationRank(char rankCard1, char rankCard2)
Takes the ranks of both cards and checks if the first card's rank is higher than the second one and returns 1 if any of the conditions are true.




Functionalities implemented by Shiv Patel:
struct node: This is a struct that holds a two chars, one for the rank of a card and another for the suit of the card. It also has a pointer to the next node because these are going to be part of the linked lists and stacks that hold the cards. I made node pointers that point to the head of each linked list in cards.h. There is one to hold the waste, the stock, the tableau, and for each foundation. 

checkFoundations: Within check foundations, after the top card of the foundations are read in to check that they're the right format, I build a linked-list that holds all the cards starting from the top 
to the Ace. I malloc struct node pointers for each new card that is created. 

checkStock: Within checkStock, after each card from the stock and the waste is read, I malloc a struct node to house the rank and the suit of the card. At the very end, I reverse the linked-list that holds the waste card because they were backwards when read in from the input. 

checkTableau: I made two arrays each of size 7, one for the covered cards in each column and one for the uncovered cards. Each index of the arrays contain a node pointer to the first covered card and the first uncovered card of each column. When reading from the input, after reading a card, I malloc space for it and it to either the uncovered or covered linked list. 

checkMoves: I impliment the moving of the cards in checkMoves. After the format of each move is read, it get passed to either validateMove, reset, or validateDot that configures the game. 

validateMove: There are several conditions in validateMove. If the move is not a dot or reset, then the game will be reconfigured in validateMove. Depending on the type of move, I manipulate either the tableau, stock, waste, or foundations linked lists by assigning and reassinging references and pointers. If the move is not valid, the function will return 0 and and error message will be thrown. 

validateDot: This is a function that reconfigures the game when a dot is read. It is simillar to validateMove in that if the move is valid then the game will be reconfigured, otherwise it will throw an error message. In this function, I manipulate the stock and waste linked lists. 

reset: This is also similar to validateMove and validateDot. This function is called after a reset is read in and if the stock is empty, then it will return 0 and error message will be printed to standard error. If there are no cards in the stock, then the waste and stock linked list are manipulated. 


